<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Michał Pękacz - Nauka CSS</title>
    <link href="normalize.css" rel="stylesheet" type="text/css" />
    <link href="style.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <header class="header">
      <button class="hamburger hamburger--js" aria-label="Otwórz menu">
        🍔
      </button>
      <nav class="navigation navigation--js">
        <a class="navigation__link navigation__link--homepage" href="index.html"
          >Strona główna</a
        >
        <a class="navigation__link" href="nauka-html.html">Nauka HTML</a>
        <a class="navigation__link" href="nauka-css.html">Nauka CSS</a>
        <a class="navigation__link" href="nauka-js.html">Nauka JavaScript</a>
        <a class="navigation__link" href="narzedzia.html">Narzędzia i linki</a>
      </nav>
    </header>
    <main class="main">
      <header class="main-header" id="top">
        <h1 class="main-header__heading">Nauka CSS</h1>
      </header>

      <section class="section">
        <h2 class="section__header">Co to jest CSS</h2>
        <p class="section__description">
          CSS=Cascading Style Sheets (kaskadowe arkusze stylów)<br />
          CSS odpowiada za prezentację/ nadawanie wyglądu na ekranach, ale także
          wydrukach, czytnikach ekranowych itp. Składnia CSS to reguły
          (selektor, właściwość, wartość).
        </p>
      </section>

      <section class="section">
        <h2 class="section__header">Nadawanie stylów - podstawy</h2>
        <article class="article">
          <h3 class="article__header">Stylowanie po nagłowkach</h3>
          <p class="article__description">
            Na początek wpiszmy znacznik style w sekcji head (w sekcji body
            widzimy treść, w sekcji head umieszczamy to co wpływa na wygląd,
            działanie strony).<br />
            <img
              class="article__image"
              src="img/css-001.JPG"
              alt="znacznik style"
            />
          </p>
          <p class="article__description">
            W związku z tym, że ostylowanych elementów może pojawić się więcej
            najlepiej style wrzucić do oddzielnego pliku. Będzie to zewnętrzny
            arkusz stylów.<br />
            <img
              class="article__image"
              src="img/css-002.JPG"
              alt="podpięcie CSS"
            />
          </p>
          <p>* to selektor uniwersalny</p>
        </article>
        <article class="article">
          <h3 class="article__header">Atrybut "style"</h3>
          <p class="article__description">
            Style mozna również dołączyć za pomocą atrybutu style, który
            przypinamy do danego znacznika, nazywa się to stylem inline
            (liniowym). Style CSS wpisujemy wewnątrz atrybutu. Możemy wpisać
            więcej niż jedną własność, np
            <img
              class="article__image"
              src="img/css-003.JPG"
              alt="atrybut style"
            />
            Korzystając z tego atrybutu może nam się pojawić bałagan w kodzie,
            zanim zobaczymy treść lista atrybutów może osiągnąc 20 i więcej
            pozycji.
          </p>
        </article>
        <article class="article">
          <h3 class="article__header">Selektory .class oraz #id</h3>
          <p class="article__description">
            Powyższe sposoby nie sprawdzą się, gdy chcemy np tylko części z
            tagów nadać osobny styl. Z pomocą przychodzi nam atrybut class
            (stylowanie za pomocą selektora klasy). Dzięki niemu możemy
            pogrupować elementy na klasy. Przypinając atrybut class do znacznika
            nadajemy mu nazwę (nazwa klasy kebab-case), a następnie w arkuszu
            stylów zamiast znacznika wpisujemy
            <b>.nazwa-klasy</b> - kropka przed nazwą to selektor klasy.
          </p>
          <p class="article__description">
            Innym sposobem jest stylowanie za pomocą id. Tak samo jak w
            poprzednim przykładzie, do znacznika dodajemy id o określonej
            nazwie, a w arkuszu CSS zamiast znacznika wpisujemy
            <b>#nazwa-id</b> - # to selektor id.
          </p>
          <p class="article__description">
            Selektory można łączyć, np chcąc wyróznić linki znajdujące się tylo
            w nawigacji (bardziej ogólnie elmenty znajdujące się w elementach)
            należy w arkuszu stylów wpisać<br />
            <img
              class="article__image"
              src="img/css-004.JPG"
              alt="łączenie selektorów"
            /><br />
            W tym przypadku jeden element nie musi byc bezpośrednio nad innym,
            taki sam efekt otrzymalibyśmy zamiast nav wpisując header, wtedy
            ostylowalibyśmy wszystkie linki znajdujące się w sekcji header.
          </p>
          <p class="article__description">
            !important - nadpisuje wszystkie rzeczy, które mogą być zdefiniowane
            dla elementów. Jeśli zdefiniujemy kolor wszystkich linków dopisując
            !important, zmieni się kolor linków także w elemencie nav,
            nadpisując wczesniej zdefiniowany kolor:<br />
            <img
              class="article__image"
              src="img/css-005.JPG"
              alt="selektor !important"
            /><br />
            Jeśli nie musimy, nie należy go stosować.
          </p>
        </article>
      </section>
      <section class="section">
        <h2 class="section__header">Specyficzność w CSS</h2>
        <p class="section__description">
          Kiedy pewien element jest ostylowany na kilka sposobów, obowiązuje
          hierarchia sposobu, w jaki ostylowaliśmy dany element:<br />
          <b>!important > style="" (inline) > #name > .name > element</b><br />
          Np wracając do przykładu z linkami w nawigacji, możemy podejrzeć w
          devtoolsach która zasada obowiązuje, a która nie(jest ona
          przekreślona).<br />
          <img
            class="section__image"
            src="img/css-006.JPG"
            alt="specyficzność - devtools"
          /><br />
        </p>
        <p class="section__description">
          Jeśli specyficzność jest równa, pierwszeństwo ma selektor "bliżej"
          elementu. Tak samo, jeśli wpiszemy dwa style w jeden selektor wygrywa
          ta własność, która jest niżej. Dobrą praktyką jest dodawać klasy do
          wszystkich elementów i unikanie zagnieżdżań (nie pisać stylów np
          header nav a), lepiej dodać klasę do elementu który nas interesuje (np
          klasa header-link do linków w nav) i stylować po tych klasach.
        </p>
        <p>Nazewnictwo klas:</p>
        <ul class="section__list">
          <li class="section__list-item">
            używamy pojedynczych słów z j. angielskiego
          </li>
          <li class="section__list-item">
            nazywamy rzeczy zgodnie z ich funkcją na stronie
          </li>
          <li class="section__list-item">nazwa z małej litery</li>
          <li class="section__list-item">nie zaczynamy od cyfr</li>
          <li class="section__list-item">
            jeśli nazwa ma więcej niż 2 słowa, używamy kebab-case
          </li>
          <li class="section__list-item">
            staramy się, żeby element miał jedną klasę (nie zwiększamy
            specyficzności bez potrzeby)
          </li>
        </ul>
      </section>
      <section class="section">
        <h2 class="section__header">Box-model</h2>
        <p class="section__description">
          Poznałem takie własności i wartości jak:
        </p>
        <ul class="section__list">
          <li class="section__list-item">
            -display: block; display: inline; display: inline-block
          </li>
          <li class="section__list-item">
            -width; height; max-width; max-height; min-width; min-height;
            overflow: visible(domyślna)/ hidden/ auto
          </li>
          <li class="section__list-item">viewport-width; viewport-height</li>
          <li class="section__list-item">
            padding; border: width/style/color; margin: auto; border-radius
          </li>
          <li class="section__list-item">border-box</li>
          <li class="section__list-item">
            position: static/ relative/ absolute; top/ right/ bottom/ left
          </li>
          <li class="section__list-item">z-index</li>
          <li class="section__list-item">position: fixed/ sticky/ float</li>
        </ul>
      </section>
      <section class="section">
        <h2 class="section__header">Flexbox</h2>
        <p class="section__description">
          Poznałem takie własności i wartości jak:
        </p>
        <ul class="section__list">
          <li class="section__list-item">display: flex</li>
          <li class="section__list-item">
            flex-direction: <b>row</b>/ column/ row-reverse/ column-reverse
          </li>
          <li class="section__list-item">
            flex-wrap: wrap/ <b>nowrap</b>/ wrap-reverse
          </li>
          <li class="section__list-item">
            flex-flow: row nowrap - domyślne wartości
          </li>
          <li class="section__list-item">
            justify-content: <b>flex-start</b>/ flex-end/ center/ space-between/
            space-around/ space-evenly
          </li>
          <li class="section__list-item">
            align-content: <b>stretch</b>/ flex-start/ flex-end/ center/
            space-between/ space-around
          </li>
          <li class="section__list-item">
            align-items: <b>stretch</b>/ flex-start/ flex-end/ center/ baseline
          </li>
          <li class="section__list-item">
            align-self: stretch/ flex-start/ flex-end/ center/ baseline
          </li>
          <li class="section__list-item">
            order - liczba całkowita (dodatnia bądź ujemna)
          </li>
          <li class="section__list-item">
            flex-grow - domyslna wartość 0. Inne wartości to liczby/ proporcje.
          </li>
          <li class="section__list-item">
            flex-shrink - 1/ liczba/ proporcja. Domyślnie 1
          </li>
          <li class="section__list-item">flex-basis - none/rozmiar bazowy</li>
          <li class="section__list-item">
            flex: flex-grow/ flex-shrink/ flex-basis
          </li>
        </ul>
      </section>
      <section class="section">
        <h2 class="section__header">Tła</h2>
        <p class="section__description">
          Background-image: url('sciezka-do-pliku'); (body class="page").
          Background-position - domyślna wartość 0 0 (lewy górny róg). Warto dać
          min-height 100vh dla body. Tło jest wyśrodkowane w rozmiarach
          orginalnych obrazka.
        </p>
        <p class="section__description">
          Gradienty. Na stronie
          <a href="https://www.grabient.com/">www.grabient.com</a> możemy
          skorzystać z gotowych lub stworzyć swój własny gradient.
        </p>
        <p>
          Własności background:
        </p>
        <ul class="section__list">
          <li class="section__list-item">
            background-repeat: repeat/ repeat-x/ repeat-y/ no-repeat/ round/
            space
          </li>
          <li class="section__list-item">
            background-attachment: <b>scroll</b>/ fixed/ local (spróbować razem
            z overflow - scroll)
          </li>
          <li class="section__list-item">
            background-origin: <b>padding-box</b>/ border-box/ content-box.
            Definiuje nam to, w którym miejscu tło powinno się zaczynać.
          </li>
          <li class="section__list-item">
            background-clip: <b>border-box</b>/ padding-box/ content-box. Mówi
            nam, w którym miejscu tło powinno byc cięte.
          </li>
          <li class="section__list-item">
            background-color: tło może byc półprzezroczyste. background-color:
            rgba.
          </li>
          <li class="section__list-item">
            background-size: <b>auto</b>/ cover/ contain/ width height. Contain
            - cały obrazek będzie się mieścił w oknie. Działa w zależności od
            repeat, position i attachment. Cover - obrazek zawsze wypełnia
            stronę niezależnie od contentu. Cover najczęściej wykorzystywany.
          </li>
        </ul>
      </section>
      <section class="section">
        <h2 class="section__header">Projekt: wizytówka</h2>
        <p class="section__description">
          Zadaniem będzie utworzenie projektu wizytówki w HTML-u na bazie
          projektu graficznego.
        </p>
        <p>Kroki i uwagi do tworzenia projektu:</p>
        <ol class="section__ordered-list">
          <li class="section__ordered-list-item">
            Utworzenie szkieletu strony, podpięcie plików ze stylami,
            wydzielenie elementów i stworzenie BEM.
          </li>
          <li class="section__ordered-list-item">
            Kolory tła i wizytówki
          </li>
          <li class="section__ordered-list-item">
            Ustawienie elementu na stronie za pomocą flexboxa.
          </li>
          <li class="section__ordered-list-item">
            Ustawienie paddingu, ustawienie lub usinięcie marginesów i
            ostylowanie każdego z elementów po kolei.
          </li>
        </ol>
        <p class="section__description">Uwagi:</p>
        <ul class="section__list">
          <li class="section__list-item">
            Jesli ustawimy we flexboxie align-content a element się nie
            wyśrodkuje, należy sprawdzić czy element nie zajmuje całej wysokości
            kontenera.
          </li>
          <li class="section__list-item">
            Możemy na body ustawić margin - lepiej to wygląda.
          </li>
          <li class="section__list-item">
            Domyślną czcionkę/rodzinę czcionek możemy wrzucić w stylach do
            elementu body.
          </li>
          <li class="section__list-item">
            nowa własność - line-height
          </li>
          <li class="section__list-item">
            Chcąc wyróżnić część tekstu możemy opakować go w tagi (strong/b),
            następnie nadać im klasę (niekoniecznie zgodną z BEM, mozna sobie
            zrobić zestaw klas służących tylko do wyróżniania)
          </li>
          <li class="section__list-item">
            Program Figma ma zakładkę kod - możemy skopiować elementy takie jak
            kolory, własności fontów.
          </li>
        </ul>
        <p class="section__description">Własności tekstu:</p>
        <ul class="section__list">
          <li class="section__list-item">
            font-family - odpowiada za czcionkę w elemencie
          </li>
          <li class="section__list-item">font-size - wielkość czcionki</li>
          <li class="section__list-item">
            font-weight: bold/normal grubość czcionki
          </li>
          <li class="section__list-item">
            font-style; italic/normal - styl czcionki
          </li>
          <li class="section__list-item">
            text-decoration: none - likwiduje podkreślenie linków i zmianę
            kolorów już odwiedzonych
          </li>
        </ul>
      </section>
      <section class="section">
        <h2 class="section__header">CSS: Grid</h2>
        <p>
          Grid powstał z potrzeby stworzenia prostego systemu do budowania
          layoutów. Cechuje go przyjazny zapis i możliwość łatwej edycji w
          kontekście responsywności. Standard dopasowany do aktualnego stanu
          stron internetowych.
        </p>
        <p>
          Grid nie zastępuje flexboxa. Grid jest stosowany do budowania całych
          layoutów a flexboxa możemy użyć do pozycjonowania/ centrowania już
          wewnątrz tego elementu. Nie używajmy flexa do budowania layoutów.
        </p>
        <p class="section__description">Cechy gridu.</p>
        <ul class="section__list">
          <li class="section__list-item">
            Numeracja w gridzie zaczyna się od 1 a nie od 0
          </li>
          <li class="section__list-item">
            Grid line - przebiega przez całość grida, rozdziela grid tracks
          </li>
          <li class="section__list-item">
            Grid track (column) - kolumna gridowa - obszar
          </li>
          <li class="section__list-item">
            Grid track (row) - wirsz gridowy - obszar
          </li>
          <li class="section__list-item">Grid cell - pojedyncza komórka</li>
          <li class="section__list-item">
            Grid Area - kilka komórek - musi być prostokątem
          </li>
        </ul>
        <p class="section__description">Atrybuty i wartości gridu.</p>
        <ul class="section__list">
          <li class="section__list-item">
            grid-template-columns: 'wartosc po spacji' np 100px 300px; tworzy
            nam kolumny o zadanych szerokościach. Jeśli dodamy kolejne elementy
            stworzy nam kolejny wiersz. Własności grid działają na jego
            bezpośrednie dzieci. Jeśli wrzucę więcej treści to wiersz mi się
            automatycznie rozszerzy. Jako jednostek możemy użyć np vw, %.
          </li>
          <li class="section__list-item">
            grid-template-rows: definiuje nam liczbę wierszy i jak te wiersze
            mają się zachowywać. W tym przypadku jeśli content jest dłuższy to
            wyjdzie poza wiersz, a wiersz bedzie trzymał zadany wymiar. Jesli
            elementów będzie więcej niż wierszy które zdefiniowaliśmy to
            nastepne elementy będą się zachowywać tak, jak dla nie
            zdefiniowanego wiersza (automatycznie rozszerzane).
          </li>
          <li class="section__list-item">
            Nowa jednostka: fr - ułamek szerokości strony. Skaluje się z
            szerokością, jednostki możemy mixować np 200px 2fr 1fr;
          </li>
          <li class="section__list-item">
            Wartość repeat, gdzie można stworzyć kilka takich samych kolumn np
            grid-template-columns: repeat(4, 200px) 1fr; podzieli nam na 4
            kolumny po 200px i jedną o szerokości 1fr.
          </li>
          <li class="section__list-item">
            min-max - działa na zakresie np grid-template-columns: 1fr
            minmax(200px, 1fr); sprawi, że zakres drugiej kolumny to minimum
            200px, maksymalnie 1fr(w tym przypadku połowa okna).
          </li>
          <li class="section__list-item">
            column-gap - odstępy między kolumnami, przerwy tworzą się tylko
            między kolumnami, nie na zewnątrz nich
          </li>
          <li class="section__list-item">
            row-gap - odstępy między wierszami, przerwy tworzą się tylko między
            wierszami, nie na zewnątrz nich
          </li>
          <li class="section__list-item">
            Linie gridu możemy też nazwać np [pierwsza] [druga] itd. (przy
            grid-template-columns) a potem przy definiowaniu zasięgu obszaru
            odnieść się do tych nazw, np grid-column-start: pierwsza;
            grid-column-end: trzecia; możemy też przy grid-column end użyć
            wartości span 3/innynumer; wtedy przejdzie przez np 3 kolumny.
          </li>
          <li class="section__list-item">
            Możemy też skorzystać z wartości grid-area: row start/ col start/
            row end/ col end, zastąpi on własności powyższe
          </li>
          <li class="section__list-item">
            Możemy też skorzystać z grid-column wartość / wartość i grid-row:
            wartość/wartość. Wszystkie zapisy są równoważne.
          </li>
        </ul>
      </section>
      <section class="section">
        <h2 class="section__header">CSS: media queries.</h2>
        <p class="section__description">
          Media queries - zapytania o media. jedna strona html może wyświetlać
          się na smartfonie/ tablecie/ laptopie i nie trzeba nic zmieniać po
          stronie kodu HTML, ale zmieniane są style. RWD - responsive web
          design.
        </p>
        <p class="section__description">
          @media wpisujemy w CSS. możemy podać media-type
          (screen/print/all/...), media-feature
          (min-width/max-width/color/aspect-ratio/orientation/...), możemy to
          łączyć za pomocą and / not / , (przecinek działa jak or w js).
        </p>
        <p class="section__description">
          Media queries nie mają wpływu na specyficzność, dlatego dobrze je
          tworzyć po zdefiniowaniu elementu.
        </p>
        <p class="section__description">
          Mobie-first. Najpierw stylujemy stronę pod urządzenia mobilne a
          później np na desktop.
        </p>
        <p class="section__description">
          Możemy ustalić kilka @media dla kolejnych wyższych rozdzielczości.dla
          każdego @media musimy wpisać odpowiednie selektory, dla których
          okreslone warunki będą spełnione.
        </p>
        <p class="section__description">
          Możemy chować elementy - display: none; i odpowiednia klasa np w tagu
          span.
        </p>
        <p class="section__description">
          Jeżeli chcemy żeby dane style były stosowane w danym zakresie możemy
          dodać np<br />
          @media screen and (min-width: 600px) and (max-width: 1023px) {<br />
          Tutaj podajemy graniczną wartość o 1 mniejszą od następnego zakresu.
          Break-pointy to zdefiniowane szerokości, na których następuje zmiana
          stylu.
        </p>
      </section>
      <section class="section">
        <h2 class="section__header">CSS: pseudoelementy i pseudoklasy.</h2>
        <article class="article">
          <h3 class="article__header">Pseudoelementy ::</h3>
          <p class="article__description">
            CSS za pomocą własności content może tworzyć treść. Używamy go
            wpisująć w css klasę elementu z dopiskiem ::before lub ::after. Nie
            można ich zaznaczyć w przeglądarce. Treść ta nie jest częścią DOM.
            Można nadać im właściwość jak np display, width, height. Można ich
            używać w celach ostylowania czegoś, np nagłówków, list, itp.
          </p>
          <h3 class="article__header">Pseudoklasy :</h3>
          <p class="article__description">
            Pseudoklasa to modyfikator elementu. Modyfikuje ona wygląd elementu,
            np podświetlenie elementu po wskazaniu go myszką przez użytkownika.
            Można go zastosować do innych rzeczy jak własności artykułów, sekcji
            itp. (:hover/ :visited/ :focus) Focus pozwala nadać własności
            elementowi, który podświetla się przy nawigacji tabulatorem, np
            elementowi input. Działa niezależnie od outline'u.
          </p>
          <p class="article__description">
            Pseudoklasy first-/ last-/ ...-child. Pozwalają one na
            zmodyfikowanie n-tego dziecka danego elementu.
          </p>
          <p class="article__description">
            not(selektor) - pozwala na zdefiniowanie np, że jeśli element nie
            jest specjalny, ma się zachowywać inaczej.
          </p>
        </article>
      </section>
    </main>
    <footer class="footer">
      Strona domowa Michała Pękacza, wszystkie treści są efektem tworzenia
      szkolenia WTF: Co ten frontend.
      <a class="footer__link" href="#top">Wróć na górę strony</a>
    </footer>
    <script src="main.js"></script>
  </body>
</html>
